/*КЛАССЫ - ЭТО ШАБЛОН (МОДЕЛЬ) ОБЪЕКТА С НАБОРОМ ЕГО СОСТОЯНИЙ И ПОВЕДЕНИЙ. КЛАСС ДОЛЖЕН ВЫПОЛНЯТЬ
КАКОЕ ТО ДЕЙСТВИЕ, КАКОЙ ТО ФУНЦЦИОНАЛ. ОПИСОВАТЬ И РЕАЛИЗОВЫВАТЬ. В ТОЖЕ ВРЕМЯ НЕ НУЖНО
ТУДА ПИХАТЬ ВСЁ ПОДРЯД.

ПРИНЦИПЫ ООП - ИНКАПСУЛЯЦИЯ, ПОЛИМОРФИЗМ, НАСЛЕДОВАНИЕ, , АБСТРАКЦИЯ

1. ИНКАПСУЛЯЦИЯ - когда мы создаём классы, описываем в них поля и правила, определяем что можно делать, а что нет.

Кузнецов Алексей написал след. определение:
Инкапсуляция - это сокрытие состояния (когда мы напрямую не может изменить состояние объекта, только через методы)
и сокрытие сложностей реализации алгоритма/решения в метод (например, в List мы не лезем внутрь метода sort, мы 
просто применяем и всё, а вся логика инкапсулирована внутри метода от нас)

1.1. Скрывает от нас сложную реализацию. Как пример, она позволяет нам пользоваться методами и не заморачиваться 
что происходит внутри него. Т.е. одно дело, если какой-либо метод написан в одно слово, и другое, если бы вся 
логика этого метода не была скрыта и приходилось каждый раз расписывать с нуля. На что тратится длит. время, 
лишний код в программе и т.д. 

1.2. Позволяет защитить данные (например, если мы в privat класе сделаем геттеры, но не сделаем сеттеры, 
то тем самым защитим данные и запретим кому-либо их изменять)   

2. ПОЛИМОРФИЗМ - МНОГООБРАЗИЕ. ЭТО ВОЗМОЖНОСТЬ РАЗНЫМ СУЩНОСТЯМ ВЫПОЛНЯТЬ ОДНИ И ТЕЖЕ ДЕЙСТВИЯ. ОБРАЗНО ГОВОРЯ 
ПОЗВОЛЯЕТ ПИСАТЬ МЕНЬШЕ КОДА и быстрее его понимать (интерфесы и т.д.).
Как пример, у нас был реализован интерфейс Notifier, в котором наши разные сущности (SmsNotifier, TelegramNotifier,
ViberNotifier, EmailNotifier) выполняли одни и теже действия по рассылке УВЕДОМЛЕНИЙ. И при необходимости,
мы в любой момент можем без труда добавить ещё не ограниченное колличество аналогичных сущностей по тем 
правилам, которые прописал разработчик

3. НАСЛЕДОВАНИЕ. (более подробно о нём в классах VK, User, Admin, Moderator)
Тоже как и ПОЛИМОРФИЗМ ПОЗВОЛЯЕТ ПИСАТЬ МЕНЬШЕ КОДА и быстрее его понимать
Например у нас есть сеть VK. Для неё создадим класс, например класс User с его полями и методами. Помимо User
у нас будет ещё один практически такой же класс Admin с идентичными полями и такими же методами + какие то 
дополнительные методы. Т.е. у нас получается одинаковый код в двух классах, а самый главный принцип КАКОЙ? От  
повторений кода нужно избавляться. Потому что, если мы исправим код в одном месте, то в других подобных местах 
можем забыть его исправить. В связи с чем, мы в классе Admin сделаем НАСЛЕДОВАНИЕ Admin от User, написав  
"public class Admin extends User"(говорим extends, наследуйся/расширь класс Admin от User. После этого, всё 
что было в User можно не писать в Admin. А повторяющийся код, в классе Admin удалим. 
НО ВАЖНЫЙ МОМЕНТ, чтобы код работал нужно в классе Admin создать конструктор, где у нас появится super, например
super (name, id). Что означает, ВЫЗОВ родительского конструктора, такой как в User. Далее мы можем дописать 
какие то свои поля

Как результат, благодаря НАСЛЕДОВАНИЮ стало меньше кода, но работать всё будет также.

Запрещено множественное НАСЛЕДОВАНИЕ. Т.е., у нашего Admin, не может быть два родителя, только один User. 
НО необходимо знать, что у User может быть свой родительский класс. Разберем это в следующий раз.
НО в свою очередь, User может быть родителем нескольких классов.

Несмотря на то, что User, является родителем наших классов Admin, Moderator и т.д., он может делать только то
что написано в коде его класса и не может делать то, что могут Admin и Moderator. User ничего не знает о 
своих потомках Admin, Moderator. Кроме того, Admin  и Moderator между собой не связаны. Но они могут быть в 
одном списке (в классе Vk), в таком как User, так как являются частью данного класса. 

4. АБСТРАКЦИЯ