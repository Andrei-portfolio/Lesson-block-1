package Лекция62910;

public class World {

    public static void main(String[] args) {

        Human jack = new Human("Джек", 30, "89277056467"); //Мы создали класс Human, сделали
        // конструктор. Теперь хотим к возрасту джека прибавить 1 год
    //        jack.age = jack.age + 1; // Прибавим jack 1 год
    //        jack.age += 1; // Тоже самое, что и jack.age = jack.age + 1
    //        jack.age ++; // Тоже самое, что и jack.age = jack.age + 1
    //        System.out.println(jack.age);

        // В програмировании должна быть какая то структура, какая то ясность. Где мы должны объяснить себе и другим
        // разработчикам, что например jack мы можем прибавить всего лишь 1 год, а не 1000 лет. Что jack
        // нельзя изменять имя и т.д. Т.е. задать какие то условия. Поэтому в объктно-ориентированом програмировании
        // существует понятие ИНКАПСУЛЯЦИЯ

        // ИНКАПСУЛЯЦИЯ - своими словами, это когда мы объясняем себе и другим, что и как мы можем менять в каком
        // то объекте, а что не можем. Может вообще ничего менять нельзя.
        // (Алексей Кузнецов) Простыми словами про Инкапсуляцию и про созданию собственного метода - мы прячем от всех
        // состояние нашего объекта, чтобы никто не наворотил делов в целостности наших данных и даём пользователям
        // работать с этими данными только через методы, запрещая изменять состояние объекту напрямую


        // Для начала напишем такую программу, в которой опишем себе и другим, например что jack может взрослеть
        // на 1 год. Для этого мы заходим в Human, где создадим собственный МЕТОД.

        // P.S. ПРИМЕР СОЗДАНИЯ СОБСТВЕННОГО МЕТОДА ПРЕДСТАВЛЕН ВО ВКЛАДКЕ HUMAN.

        // Теперь, создав собственный метод getOlder, мы можем вызвать его. Для этого введем наше jack. После точки в
        // выпадающем списке выбираем метод getOlder (voild).
        //
        //        jack.getOlder();
        //        jack.getOlder();
        //        System.out.println(jack.age);

        //Вызвав данный метод, в терминал приходит ответ, что jack 31 год. А выше надпись, "У меня день рождения!!!"
        // Если мы вызовим данный метод ещё раз, то возраст джека увеличится ещё на 1 год. Метод getOlder у нас рабочий.

        // (Марсель Файзулин). А что нужно написать в методе getOlder, чтобы в классе world нельзя было прибавить
        // 1000 лет. Ответ преподавателя: если только 900 раз напишем строчку jack.getOlder();
        //
        //        jack.getOlder();
        //        jack.getOlder();
        //        jack.getOlder();
        //        ..............

        // Далее подробно рассмотрим для чего это делали, что мы не доделали и что нужно сделать!!!!
        // Итак, всё что выше, то представлено применением методов БЕЗ ПРИМЕНЕНИЯ УСЛОВНЫХ ОПЕРАТОРОВ, чтобы не
        // запутать нас. Ну а ниже с применением условных операторов, приведенных во вкладке HUMAN

        // jack.getOlder();
        // System.out.println(jack.age); // P.S. Будет работать если в классе HUMAN изменю МОДИФИКАТОР ДОСТУПА
        // полей с приватного private на публичный public

        // Итак, ПРИ ВЫЗОВЕ видно, что джеку можно прибавлять по 1 году до верхней границы в 125 лет. А как это
        // проверить? Очень просто. В самом начале данного листа при создании объекта в строке
        // Human jack = new Human("Джек", 60); меняем возраст на 124 года и будет Human jack = new Human("Джек", 124);
        // Далее вызываем ответ в терминал и видим сообщение в нём: 125 "Вы достигли границы возраста". Если вызвать
        // с меньшим возрастом, то будет написан возраст и надпись "У меня день рождения!!!"

        // Но как и сказали в чате, мы по прежнему можем обмануть систему и между методом jack.getOlder();
        // и System.out.println(jack.age); написать jack.age += 1000; и возраст нашего jack станет 1030 лет.

        //jack.getOlder();
        // jack.age += 1000;               // P.S. Будет работать если в классе HUMAN изменю МОДИФИКАТОР ДОСТУПА
        // System.out.println(jack.age);   // полей с приватного private на публичный public

        // А чтобы этого избежать, необходимо исключить возможность вызова всех методов как для нас, так и для других
        // разработчиков. Т.е. когда мы, или кто-то набирает, например jack и ставит точку для вызова метода. То
        // в списке в принципе не было ни age, ни name и так далее. Т.е. скрыть их. А оставить только нужные для нас.
        // Например только созданный нами метод jack.getOlder. Иначе пока там есть данные поля, мы можем их
        // использовать и делать с ними всё что захотим, и это чревато нежелательными последствиями.

        // Итак, а для выполнения вышесказанного, нам необходимо в классе HUMAN изменить МОДИФИКАТОР ДОСТУПА полей
        // с публичного public,на private. И в будущем при создании класса, по умолчанию ВСЕГДА НЕОБХОДИМО ПИСАТЬ
        // КАКИЕ У НАС ПОЛЯ: public или private. До этого урока, если напротив поля не написано было в каком классе
        // они использовались,то на самом деле это было public (т.к. МЫ ИХ МОГЛИ ЖЕ ИСПОЛЬЗОВАТЬ В ДРУГОМ КЛАССЕ world).
        // Теперь мы будем писать в каком классе поля и в классе HUMAN поставим private.
        //
        // Итак, заменив МОДИФИКАТОР ДОСТУПА public на private, тем самым в данном классе, где мы использовали age,
        // выдаются ошибки. Кроме того, если мы наберем jack. и попробуем посмотреть методы, то там будет только
        // один getOlder. Ну и верно, тем самым мы ограничили возможность кому либо работать с остальными полями и
        // изменять их. А также их посмотреть. НО, есть возможность прописать МЕТОД, чтобы можно было обратиться и
        // вызвать данные поля и их значения.
        //

        // jack.showMyAge(); // showMyAge выглядит не очень корректно. На самом деле мы должны в классе HUMAN
        // создать ГЕТТЕРЫ, от слова GET получить данные. Это методы, которые просто возвращают
        // данные

        int jackAge = jack.getAge(); // Что делает этот метод? Он ничего не делает, кроме того, что просто возвращает
        // данные, в нашем случае возраст. Чтобы возратить другие поля будем писать
        // getName, getPhone и т.д. Пример приведём ниже
        System.out.println(jack.getAge());

        String jackName = jack.getName();// Данный метод возвращает данные, в нашем случае имя джека
        System.out.println(jack.getName());

        // В части инкапсуляции, что мы сделали хорошего? С помощью getOlder мы можем изменить данные, строго на ту
        //  величину, которая допустима, которую мы разрешили +1. Ну а с помощью getAge мы можем получить значение. Но
        // ничего с ним сделать не сможем, так как у нас защищенное значение поле age. Мы знаем, что в классе World
        // ничего не могут сделать. Единственное что смогут, это увеличить возраст каждый раз на +1 год до допустимого
        // значения 125 лет. И второе, это посмотреть значение поля age.

        jack.setPhone("8 (846) 2-28-57"); //ВАЖНО!!! Самое интересное, чтобы отработал СЕТТЕР, ножно чтобы в классе
        // также был создан ГЕТТЕР. Видно, что в этой строчке setPhone, в следующей
        // getPhone. Соответственно, для этого нужно в классе создать ГЕТТЕР
        System.out.println(jack.getPhone());
    }
}
