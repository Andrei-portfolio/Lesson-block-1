package Лекция142611.Tails.Generics;

import Лекция142611.Tails.Methods.Human;

public class CustomerApiServiceTest {

    /*Далее перейдём к ещё одному хвосту - ДЖЕНЕРИКИ. мы на самом деле уже раньше встречались
    с НИМИ, но мы не знали что это были они. Как пример, в Лекция111411.XMLCollection классе
    Users имеется следующий код.

    @XmlElement(name = "user")// Данная аннотация нужна, чтобы работать со списками, если не
                              //укажем ошибка
    private List<User> users;// Объявляем список в классе обёртки. Просто список. Мы говорим,
    //из этого списка users бери элементы и в XML файл сохраняй с таким вот именем "user". Если
    //его поеняем, изменится и в имя в XML файле

    List<User> (интерфейс лист, массив, список), это и есть Generics. А почему? Потому что Generics
    - это класс, который на вход принимает какйто тип данных. Какой, мы вибираем сами, и записываем
    после класса в угловых скобках, например "<User>". Где User мы можем заменить, как на int, String,
     Float и т.д.

    Если грубо обобщить - Generics - это такое обобщение, которое говорит что все наши методы для
    любого типа данных работают одинаково

    Пригодиться это может в следующем случае. Например, когда мы тестируем API запросы или ответы по
    какому-то сервису покупателей. И нам нужно получить какой то ответ response. Но его нужно где-то
    хранить, поэтому создадим класс HttpResponse. У ответа есть три параметра: статус код, заголовок
    и тело.
     */

    public static void main(String[] args) {

    HttpResponse httpResponseHuman = new HttpResponse(200);

    /*В каком то другом запросе к нам приходит не Human, а например Elf. А это другой класс, там
    соответственно другие поля. Возникает вопрос, как же мы будем валидировать Elf, если в классе
      httpResponse мы написали, что ожидаем Human (private Human body;). Поэтому мы заранее должны
      сказать, что не знаем какой тип придёт. Поэтому мы вместо Human напишем набор любых букв,
      или одну букву, например "T"

      После чего, изменим код, который написали выше и закомитим, а в коде ниже  добавим в угловые
      скобки <Human> и <Elf>
      */

        HttpResponse httpResponseElf = new HttpResponse<Elf>(400);
        HttpResponse httpResponseHuman1 = new HttpResponse<Human>(200);

    }
}
