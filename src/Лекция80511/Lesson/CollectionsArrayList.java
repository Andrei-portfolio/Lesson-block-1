package Лекция80511.Lesson;

import Лекция73110.Продолжение.Human;

import java.util.ArrayList;
import java.util.List;

public class CollectionsArrayList {

    public static void main(String[] args) {

        // Вспомним массив чисел
        // НИЖЕ ПРЕДСТАВИМ НЕДОСТАТКИ МАССИВА:


//        int[] number = {1, 2, 3, 4, 5}; // Это если мы зарание знаем какие будут элементы
//
//        String[] berries = new String[10]; // Какие то числа, не более 10 элементов
//        berries[0] = "Малина";
//        berries[1] = "Клубника";
//        for (String berrie : berries) {
//            System.out.println(berrie.toUpperCase()); // Здесь мы сказали, обратись к 10ти ягодам и выведи их с
        // заглавной буквы с помощью метода toUpperCase. Соответственно, он делает МАЛИНА и КЛУБНИКА, а потом
        // null. А null это не строка, у него нет метода toUpperCase. Поэтому он не может выполнить и падает
        // выпадает с ошибкой "Cannot invoke "String.toUpperCase()" because "fruit" is null".
        // ЭТО ОДИН ИЗ НЕДОСТАТКОВ МАССИВОВ. ГДЕ ЕСЛИ МЫ НАПИСАЛИ 10 ЭЛЕМЕНТОВ, ЗНАЧИТ 10 И ДОЛЖНЫ
        // ПОЛОЖИТЬ В МАССИВ. Иначе, если мы забудет какой то из элементов, будет ошибка, так как заполняется
        // пустотой.

        // Чтобы можно было увидеть, что выдаёт null, нужно убрать метод написания фруктов с заглавной буквы,
        // а оставить просто вывод все фруктов  System.out.println(berrie);


        //Ещё один недостаток массива, что нет как токовой операции удаления элементов. Если только мы добавим
        // следующую строку berries[0] = null; Т.е. выше написано, что berries[0] = "Малина"; Получается данный
        // элемент массива будет удалён и равен null. Но чтобы проверить, нам опять надо вызвать
        // System.out.println(berrie). В терминале наша удаленная "Малина" пропала, но на её месте появилось null.
        // И в итоге в терминале у нас остаётся один "Клубника", окруженный null. А это не красиво и неудобно.
        // Ещё один недостаток, что мы не можем расширять массив. Если написано 10, значит не более.


        //Чтобы исправить все вышеперечисленные недостатки массива, придумали framework КОЛЛЕКЦИИ, КОТОРЫЙ
        // ВКЛЮЧАЕТ В СЕБЯ кучу разных видов списков, основанных на массивах


        // Чтобы создать список мы используем интерфейс List. Самые попуярные ArrayList и LinkedList

        List<String> fruits = new ArrayList<>(); // В угловых сбобках мы должны указать тип переменной, который
        // будем хранить в нашем списке, т.е. также, как мы и указывали с массивом. После new нам будет предлагать
        // много листов, но мы пока выберем ArrayList. Далее, как с ним работать. Для примера возьмем тот
        //же самый цикл

        //for (String fruit : fruits) {
        //System.out.println(fruit.toUpperCase());
        //System.out.println(fruit);

        // Всё чётенько, наш ArrayLis не выдал никаких элементов, ну и правильно у нас нет никого, поэтому
        // и не вывел. Даже null не вывел. Кроме того, обратить вниманее, что мы не задали размер данного
        // листа. Ну и правильно, так как мы не знаем заранее сколько у нас будет элементов.

        // Это у нас интерфейс лист и мы от него создали список фруктов. Раз List это интерфейс, а ArrayList
        // это класс, который имплементируется от интерфейса. Получается и у нашего класса есть методы.
        // Для этого, перед циклом выше поставим fruits. и из списка выберем метод add (типа String e). ДАННЫЙ
        // МЕТОД add ДОБАВЛЯЕТ В СПИСОК ЭЛЕМЕНТЫ. Как пример, добавим в список бананы и ананас.

        fruits.add("Яблоко");
        fruits.add("Аппельсин");
        fruits.add("Ананас");
        fruits.add("Бананы");


        // Если же мы хотим добавить элементы по адресу [0], [1], [2] элемент и т.д. То для этого используем
        // add (типа int index, String element)

        fruits.add(0, "Мандарин"); // Первым добавляем индекс, Вторым сам элемент. Получается
        // нулевым элементом добавится "Мандарин". А что будет с остальными? Они просто сдвинуться на один
        fruits.add(3, "Киви");


        //Создадим ещё один список фруктов и назовём его fruits2 и добавим туда apple

        List<String> fruits2 = new ArrayList<>(); // Создали новый список фруктов
        fruits2.add("Apple"); // Добавили в список яблоко
        fruits2.addAll(fruits); // Так же в наш список через addAll добавляем старый список с яблоками fruits.
        // Это удобный вариант, чтобы добавить целый список
        // Кроме того, напишем более удобный вариант, чтобы вывести наш список

        System.out.println(fruits2);

        for (String fruit : fruits) {
            System.out.println(fruit);
        }

        // Чему нам нужно будет научиться в итоге при работе со списками. Как их добавлять, использовать
        // и удалять элементы. Добавление рассмотрели, теперь посмотрим удаление и использование элементов.
        // (подсчет, обращение к элементу). Для начала сделаем удаление с помощью REMOVE
        // НАПОДОБИЕ ЕСТЬ ЗАДАНИЕ в домашке про список дел


        List<String> fruits3 = new ArrayList<>();
        fruits3.add("НеЯблоко"); // Добавление элемента типа add (String E). Чуть иже представлена вставка эл-та,
        fruits3.add("НеАппельсин"); // главное отличие вставки от добавления, что добавление добав. в конец списка,
        fruits3.add("НеАнанас"); // а вставка на конкретное место или номер, указанный в скобках
        fruits3.add("НеБананы");
        fruits3.add(2,"ПолуАпельсин"); // Вставка элемента типа add (i, value)
        fruits3.remove(0); // remove Удаляем нулевой элемент, это будет наше "НеЯблоко"
        fruits3.remove("НеАппельсин"); // remove Пример удаления элемента не по индексу, а по названию
        fruits3.set(0, "Ненемандарин"); // set метод изменения или подмены
        System.out.println(fruits3.size()); //Данный метод size помогает нам подсчитать количество элементов списка
        System.out.println("Выведи нам самый первый элемент: " + fruits3.get(0)); //  Ну а обратиться,например к
        // нулевому элементу можем с помощью метода get

        for (String fruit : fruits3) {
            System.out.println(fruit);
        }

        // Рассмотрим ещё один ArrayList на примере класса Human, созданного в 5 лекции. НАПОДОБИЕ ЕСТЬ ЗАДАНИЕ
        // в домашнем задании про список объектов


        List<Human> humans = new ArrayList<>(); // Создали список, указали тип Human

        humans.add(new Human("John", 30)); // Добавили объект этого класса new Human с помощью add
        humans.add(new Human("Jack", 32));
        humans.add(new Human("Sam", 34));

        System.out.println(humans.get(0).getName()); //Говорим "Обратись к 0 элементу списка и получи его имя"

              for (Human human : humans) {// Обратимся через цикл и выведем в терминал информацию по именам
                                        // и возрасту
            System.out.println(human.getName() + " " + human.getAge());

        }

        // Далее рассмотрим, внутреннее устройство работы данного ArrayList. Чтобы не писать неоптимизированный
        // код, который будет только засорять и замедлять работу. Конечно данная информация прежде всего
        // необходима для разработчиков. Но данный вопрос могут спросить на собеседовании


        // Когда мы создаём массив, мы указываем количество элементов, которое будет в массиве
        // String[] fruits = String [5].Когда создаем ArrayList мы это не делаем
        // List<Human> humans = new ArrayList<>()
        //
        //1. Если мы не указываем значение, то с ArrayList у нас автоматически создаётся массив из 10 элементов.
        // 2. После того, как мы их все 10 заполнили, наш массив копируется и автоматически расширяется новым
        // массивом в 1,5 раза больше. Т.е. создаётся новый массив размером в 1,5 раза больше + 1.
        //3. Туда копируются наши прошлые значения
        //4. Старый массив будет удален сборщиком мусора
        //"5. Когда мы удаляем один из элементов, те которые шли за ним сдвигаются на один шаг. Получается ArrayList
        // при удалении может затрагивать большое количество элементов. Тоже самое происходит и при добавлении
        // элементов, например в самое начало. Т.е. последующие также сдвигаются. Поэтому при очень большом
        // количестве элементов в  ArrayList, удаление или добавление может занимать некоторое время. Особенно,
        // если мы добавляем или удаляем в начале массива. (Для сравнения, в массиве же при удалении,
        // элемент просто становится пустым и показывает null). В связи с чем, далее рассмотрим ещё одну
        // разновидность списка . Это разновидность списка List, у которого присутствуют всё теже самые методы
        // remove, add,size, get и т.д.
        //
        // Далее переходим в другой класс, где будет продемонстрирована разновидность другого списка. А для этого
        // тупо скопируем код с этого листа и скопируем его в CollectionsLinkedList. После замены на
        // LinkedList посмотрим как он работает. Основной плюс, что LinkedList и ArrayList реализованы с одного
        // интерфейса, а соответственно мы просто поменяли названия листов и в терминал получили тоже самое.

        // А теперь боле подробно про LinkedList и его преимущества. В переводе он обозначает "Связанный список".
        // Что означает, что все элементы стоящие по соседству знают адрес друг друга. Поэтому при удалении одного
        // из элементов изменение произойдет только в соседних ячейках (справа и слева от элемента). Допустим,
        // при удалении "Яблоко" в списке "Апельсин" "Яблоко" "Банан", то у апельсина поменяется сосед справа и
        // станет банан. И второе изменение, у банана вместо яблока соседом будет апельсин. И всё, т.е. произойдет
        // всего два изменения, остальные даже не знали что один из элементов был удален. ЭТО главное ПРЕИМУЩЕСТВО
        // LinkedList, когда мы часто будем или удалять или добавлять.

        // Недостаток LinkedList. В нём, как уже говорилось выше, элементы знают информацию только о соседних ячейках.
        // Поэтому чем длинее массив в LinkedList , тем сложнее нам на уровне кампиляции будет найти нужный нам
        // элемент с помощью get. На уровне java мы то это практически не заметим, у нас ничего не меняется.
        // Имеется в виду, что при частом добавлении или удалении элементов, LinkedList проигрывает в скорости
        // ArrayList


        // Перейдем к HashMap - это что то типо словаря или ассоциативного массива. Здесь мы можем также использовать
        // любые типы переменных. HashMap применяем, Когда нам недостаточно создать список и вместо инднксов
        // (1, 2, 3 и т.д.) использовать более красивые и понятные обозначения названия, какие то ключи как в json
        // (пара ключ - значение).
    }
}